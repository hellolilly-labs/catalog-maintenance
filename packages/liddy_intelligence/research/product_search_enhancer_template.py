"""
Product Search Enhancer Prompt Template

This module defines the structure and content for the tactical search enhancement prompt
that will be generated by ProductCatalogResearcher and used by the search service.
"""

def get_search_enhancer_prompt_template() -> str:
    """
    Get the template for Part C of ProductCatalogResearcher output.
    This creates a compact, ready-to-use prompt for search query enhancement.
    """
    
    return """
## Part C: Product Search Enhancement Prompt

**THIS SECTION IS FOR DIRECT USE IN SEARCH QUERY ENHANCEMENT - COPY AS-IS**

### Search Enhancement Instructions for {{brand_name}}

You are enhancing product search queries for {{brand_name}}. Apply these specific insights:

#### 1. Brand-Specific Terminology
Transform generic terms to {{brand_name}}-specific language:
{{brand_terminology_mappings}}

#### 2. Product Category Intelligence
When users search broadly, guide them to these specific categories:
{{category_guidance}}

#### 3. Technical Translation Rules
Convert customer language to product specifications:
{{technical_translations}}

#### 4. Feature Expansion Patterns
Expand simple queries with relevant features:
{{feature_expansions}}

#### 5. Use Case Associations
Connect problems/needs to product solutions:
{{use_case_mappings}}

#### 6. Query Enhancement Examples
{{enhancement_examples}}

#### Search Enhancement Rules:
1. **Maintain Intent**: Never change what the user is looking for, only enhance how they express it
2. **Add Context**: Include relevant technical terms, features, and specifications that match the intent
3. **Expand Synonyms**: Add {{brand_name}}-specific terminology alongside generic terms
4. **Include Attributes**: Add likely filters (price range, category, features) based on query context
5. **Preserve Simplicity**: Keep enhanced queries natural and not overly complex

**END OF SEARCH ENHANCEMENT PROMPT**
"""


def generate_brand_specific_content(research_content: str, brand_name: str) -> dict:
    """
    Extract and format brand-specific content from the full research.
    
    This would analyze the research content and extract:
    - Common terminology mappings
    - Category hierarchies
    - Technical specifications patterns
    - Feature associations
    - Use case mappings
    
    Returns a dictionary with formatted content for each section.
    """
    
    # This is a placeholder structure - actual implementation would parse research
    return {
        "brand_terminology_mappings": """
- "bike" → "bicycle", "cycle", "{{brand_name}} bike"
- "fast" → "high-performance", "race-ready", "speed-optimized"
- "comfortable" → "ergonomic", "endurance-focused", "comfort-geometry"
- "cheap" → "value", "entry-level", "budget-friendly"
- "expensive" → "premium", "top-tier", "professional-grade"
        """.strip(),
        
        "category_guidance": """
- General "bike" → Check: Mountain (MTB), Road, Gravel, E-Bike, Urban
- "Exercise" → Focus on: Road bikes, Indoor trainers, Fitness hybrids
- "Commute" → Prioritize: Urban, E-Bike, Folding options
- "Adventure" → Suggest: Gravel, Touring, Bikepacking models
        """.strip(),
        
        "technical_translations": """
- "lightweight" → "under 20 lbs", "carbon frame", "weight: <9kg"
- "durable" → "aluminum frame", "steel frame", "warranty", "all-weather"
- "smooth ride" → "suspension", "vibration damping", "comfort geometry"
- "easy to ride" → "stable geometry", "wide gear range", "beginner-friendly"
        """.strip(),
        
        "feature_expansions": """
- "mountain bike" → +"full suspension" | "hardtail", "29er" | "27.5", "trail" | "XC" | "enduro"
- "road bike" → +"carbon" | "aluminum", "105" | "Ultegra" | "Dura-Ace", "disc brakes" | "rim brakes"
- "electric" → +"e-bike", "pedal assist", "motor power", "battery range", "Class 1" | "Class 3"
        """.strip(),
        
        "use_case_mappings": """
- "hills" / "climbing" → lightweight frames, wide gear range, compact cranksets
- "long rides" / "touring" → endurance geometry, comfortable saddles, mounting points
- "racing" / "speed" → aerodynamic frames, aggressive geometry, high-end components
- "fitness" / "exercise" → versatile bikes, upright position, reliable components
        """.strip(),
        
        "enhancement_examples": f"""
Original: "cheap mountain bike"
Enhanced: "entry-level mountain bike hardtail under $1000 trail recreational {brand_name}"

Original: "bike for hills"  
Enhanced: "lightweight bike climbing hills wide gear range compact crankset road gravel {brand_name}"

Original: "comfortable bike for long rides"
Enhanced: "endurance bike comfortable geometry touring long distance rides {brand_name}"
        """.strip()
    }


def format_search_enhancer_prompt(template: str, brand_content: dict, brand_name: str) -> str:
    """
    Format the final search enhancer prompt with brand-specific content.
    """
    
    prompt = template.replace("{{brand_name}}", brand_name)
    
    for key, value in brand_content.items():
        prompt = prompt.replace(f"{{{{{key}}}}}", value)
    
    return prompt


# Example of how to extract the prompt from existing research
def extract_search_prompt_from_research(research_content: str) -> str:
    """
    Extract the Part C search enhancement prompt from full research content.
    
    Args:
        research_content: The full ProductCatalogResearcher output
        
    Returns:
        The extracted search enhancement prompt, or empty string if not found
    """
    
    # Look for the Part C section
    start_marker = "## Part C: Product Search Enhancement Prompt"
    end_marker = "**END OF SEARCH ENHANCEMENT PROMPT**"
    
    start_idx = research_content.find(start_marker)
    if start_idx == -1:
        return ""
    
    end_idx = research_content.find(end_marker, start_idx)
    if end_idx == -1:
        return ""
    
    # Extract the content between markers (including the end marker)
    prompt_content = research_content[start_idx:end_idx + len(end_marker)]
    
    # Find the actual prompt content (after the instructions line)
    instructions_marker = "**THIS SECTION IS FOR DIRECT USE IN SEARCH QUERY ENHANCEMENT - COPY AS-IS**"
    instructions_idx = prompt_content.find(instructions_marker)
    
    if instructions_idx != -1:
        # Return content after the instructions
        return prompt_content[instructions_idx + len(instructions_marker):].strip()
    
    return prompt_content.strip()


# Proposed structure for storing this separately
SEARCH_PROMPT_STORAGE_PATH = "research/product_catalog/search_enhancer_prompt.txt"

"""
Benefits of this approach:

1. **Compact & Focused**: Much smaller than the full research document
2. **Ready to Use**: Can be copied directly into search enhancement prompts
3. **Cached Separately**: Can be stored in a dedicated file for quick access
4. **Version Controlled**: Part of the research output, so it updates when research updates
5. **Context Aware**: Generated from the full research, so it captures all insights
6. **Examples Included**: Provides concrete examples for the LLM to follow

Integration points:

1. ProductCatalogResearcher: Generate Part C using this template
2. AccountManager: Add method to extract and cache this prompt
3. SearchService: Use the cached prompt instead of full research
4. Voice Search: Can use the same prompt for consistency
"""